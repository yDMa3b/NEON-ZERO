<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>NEON CORE: FINAL SPEED</title>
<style>
    * { box-sizing: border-box; touch-action: none; user-select: none; -webkit-user-select: none; }
    body { margin: 0; background: #111; font-family: sans-serif; overflow: hidden; }
    canvas { display: block; width: 100%; height: 100%; background: #000; }

    /* UI */
    #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
    .top-bar { padding: 15px 20px; display: flex; justify-content: space-between; }
    .score-big { font-size: 3rem; color: #fff; font-weight: 900; font-style: italic; text-shadow: 0 0 15px #0ff; line-height: 0.8; }
    .label { font-size: 0.8rem; color: #666; font-weight: bold; letter-spacing: 2px; margin-left: 2px; }
    .hp-row { display: flex; gap: 5px; justify-content: flex-end; margin-top: 5px; }
    .hp-bit { width: 30px; height: 8px; background: #0ff; transform: skewX(-20deg); transition: 0.2s; box-shadow: 0 0 8px #0ff; }
    .hp-bit.off { background: #444; opacity: 0.3; box-shadow: none; }

    #msg {
        position: absolute; top: 35%; width: 100%; text-align: center;
        font-size: 2.5rem; color: #fd0; font-weight: 900; letter-spacing: 1px;
        text-shadow: 0 3px 10px #000; opacity: 0; transition: transform 0.1s;
    }

    #guide {
        position: absolute; bottom: 20%; width: 100%; text-align: center;
        font-size: 2rem; font-weight: 900; color: #fff; text-shadow: 0 0 20px #0ff;
        animation: beat 0.5s infinite alternate; pointer-events: none; display: none;
    }

    /* 虚拟操控 */
    #touch-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 20; }
    .joystick-zone {
        position: absolute; bottom: 60px; left: 60px; width: 160px; height: 160px;
        border: 2px dashed rgba(255,255,255,0.15); border-radius: 50%;
        pointer-events: auto; cursor: move;
    }
    .joystick-head {
        position: absolute; top: 50%; left: 50%; width: 60px; height: 60px;
        background: rgba(0,255,255,0.3); border: 2px solid #0ff; border-radius: 50%;
        transform: translate(-50%, -50%); pointer-events: none;
        box-shadow: 0 0 15px rgba(0,255,255,0.2);
    }
    .parry-btn {
        position: absolute; bottom: 60px; right: 60px; width: 110px; height: 110px;
        background: rgba(255,50,50,0.2); border: 3px solid #f44; border-radius: 50%;
        color: #fff; font-weight: bold; font-size: 1.2rem;
        display: flex; align-items: center; justify-content: center;
        pointer-events: auto; cursor: pointer; user-select: none;
        box-shadow: 0 0 20px rgba(255,0,0,0.2);
    }
    .parry-btn:active { transform: scale(0.95); background: rgba(255,50,50,0.5); }

    /* 菜单 */
    #menu {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.92); z-index: 50;
        display: flex; flex-direction: column; justify-content: center; align-items: center;
    }
    .start-btn {
        margin-top: 40px; padding: 15px 60px; font-size: 1.5rem; 
        background: #0ff; border: none; font-weight: 900; cursor: pointer;
        clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
        box-shadow: 0 0 30px rgba(0,255,255,0.3);
    }
    
    @keyframes beat { from{transform:scale(1);} to{transform:scale(1.1);} }
    .hidden { display: none !important; }
</style>
</head>
<body>

<div id="ui-layer">
    <div class="top-bar">
        <div>
            <div class="score-big" id="ui-score">0</div>
            <div class="label">SYNC RATE</div>
        </div>
        <div class="hp-box">
            <div class="label">STATUS</div>
            <div class="hp-row" id="ui-hp">
                <div class="hp-bit"></div><div class="hp-bit"></div><div class="hp-bit"></div>
            </div>
        </div>
    </div>
    <div id="msg">PERFECT</div>
    <div id="guide">点击格挡</div>
</div>

<div id="touch-layer">
    <div class="joystick-zone" id="joy-wrap">
        <div class="joystick-head" id="joy-ball"></div>
    </div>
    <div class="parry-btn" id="btn-action">格挡</div>
</div>

<div id="menu">
    <h1 style="font-size:4rem; color:#fff; text-shadow:0 0 20px #0ff; margin:0; font-style:italic;">NEON CORE</h1>
    <div id="game-over-text" class="hidden" style="color:#f44; font-size:1.5rem; margin-bottom:20px; font-weight:bold; margin-top:20px;">链接中断</div>
    <button class="start-btn" id="btn-start">启动系统</button>
</div>

<canvas id="canvas"></canvas>

<script>
window.onerror = function(msg){ alert('Error: '+msg); return false; };

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { alpha: false });
let W = canvas.width = window.innerWidth;
let H = canvas.height = window.innerHeight;

// === 全局状态 ===
const State = {
    active: false, score: 0, timeScale: 1.0,
    entities: [], particles: [], player: null,
    tutorial: true, waitInput: false, shake: 0, freeze: 0
};

// === 音频 ===
const AudioSys = {
    ctx: null,
    init() {
        try {
            window.AudioContext = window.AudioContext||window.webkitAudioContext;
            this.ctx = new AudioContext();
        } catch(e){}
    },
    play(f, t, d, v=0.1, s=0) {
        if(!this.ctx) return;
        try {
            const o=this.ctx.createOscillator(), g=this.ctx.createGain(), time=this.ctx.currentTime;
            o.type=t; o.frequency.setValueAtTime(f, time);
            if(s) o.frequency.linearRampToValueAtTime(f+s, time+d);
            g.gain.setValueAtTime(v, time); g.gain.exponentialRampToValueAtTime(0.001, time+d);
            o.connect(g); g.connect(this.ctx.destination); o.start(); o.stop(time+d);
        } catch(e){}
    },
    sfx: {
        p: () => AudioSys.play(600,'square',0.2,0.2),
        pf: () => { AudioSys.play(1000,'square',0.3,0.3); setTimeout(()=>AudioSys.play(2000,'sine',0.4,0.2),40); },
        h: () => { AudioSys.play(100,'sawtooth',0.4,0.5); AudioSys.play(50,'square',0.4,0.5); },
        k: () => AudioSys.play(150,'square',0.2,0.1),
        sh: () => AudioSys.play(220,'triangle',0.1,0.05),
        sl: () => AudioSys.play(300,'sine',0.8,0.2)
    }
};

// === 输入 ===
const Input = {
    x:0, y:0, keys:{},
    init() {
        window.onkeydown = e => {
            const k = e.key.toLowerCase();
            if('wasd'.includes(k)) this.keys[k]=true;
            if(e.code==='Space' && State.active && State.player) State.player.parry();
        };
        window.onkeyup = e => {
            const k = e.key.toLowerCase();
            if('wasd'.includes(k)) this.keys[k]=false;
        };
        // 摇杆
        const j = document.getElementById('joy-wrap'), b = document.getElementById('joy-ball');
        let sx, sy;
        j.onpointerdown = e => {
            e.preventDefault(); sx=e.clientX; sy=e.clientY; j.setPointerCapture(e.pointerId);
            j.onpointermove = m => {
                let dx=m.clientX-sx, dy=m.clientY-sy;
                let d=Math.hypot(dx,dy), max=50;
                if(d>max) { dx=(dx/d)*max; dy=(dy/d)*max; }
                b.style.transform=`translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                this.x=dx/max; this.y=dy/max;
            };
        };
        j.onpointerup = j.onpointercancel = () => { this.x=0; this.y=0; b.style.transform='translate(-50%,-50%)'; j.onpointermove=null; };
        // 按钮
        document.getElementById('btn-action').onpointerdown = e => {
            e.preventDefault(); if(State.player) State.player.parry();
        };
    },
    getVec() {
        let dx=0, dy=0;
        if(this.keys.w) dy=-1; if(this.keys.s) dy=1; if(this.keys.a) dx=-1; if(this.keys.d) dx=1;
        return (dx||dy) ? {x:dx,y:dy} : {x:this.x,y:this.y};
    }
};

// === 实体 ===
class Player {
    constructor(x,y){ this.x=x;this.y=y;this.hp=3; this.vx=0;this.vy=0; this.pt=0;this.cd=0; }
    update(dt){
        const v = Input.getVec();
        // *** 极速手感调优 ***
        const acc = 7000 * dt; // 加速度翻倍
        const drag = 0.85;     // 阻尼微调，让极速更高
        
        this.vx += v.x * acc; this.vy += v.y * acc;
        this.vx *= drag; this.vy *= drag;
        
        this.x += this.vx*dt; this.y += this.vy*dt;
        this.x = Math.max(20,Math.min(W-20,this.x)); this.y = Math.max(20,Math.min(H-20,this.y));
        if(this.pt>0) this.pt-=dt; if(this.cd>0) this.cd-=dt;
    }
    parry() { if(this.cd<=0) { this.pt=0.25; this.cd=0.5; FX.burst(this.x,this.y,'#fff',5); } }
    draw(c) {
        c.translate(this.x,this.y);
        c.fillStyle=this.pt>0?'#fff':'#0ff';
        c.beginPath(); c.moveTo(0,-15); c.lineTo(12,10); c.lineTo(0,5); c.lineTo(-12,10); c.fill();
        if(this.pt>0 || State.waitInput) {
            c.lineWidth=2; c.strokeStyle='rgba(0,255,255,0.4)'; c.beginPath(); c.arc(0,0,90,0,7); c.stroke(); // 普通圈
            c.strokeStyle='#ffd700'; c.beginPath(); c.arc(0,0,125,0,7); c.stroke(); // 完美金圈
        }
        c.setTransform(1,0,0,1,0,0);
    }
}

class Bullet {
    constructor(x,y,a,h){ 
        this.type='b'; this.x=x; this.y=y; this.a=a; this.h=h;
        this.spd=h?(350+State.score/20):1100; 
        this.c=h?'#f44':'#0ff';
        this.auto=false; // 标记是否是自动防御弹开的
    }
    update(dt) { this.x+=Math.cos(this.a)*this.spd*dt; this.y+=Math.sin(this.a)*this.spd*dt; }
    reflect(perf, isAuto=false) {
        this.h=false; this.auto=isAuto; // 记录属性
        
        this.c = isAuto ? '#666' : (perf?'#ffd700':'#0ff'); // 自动灰，完美金，普通蓝
        this.spd = isAuto ? 800 : (perf?1600:1200);
        this.perf = perf;

        let t = State.entities.find(e=>e.type==='e' && !e.dead);
        if(t) this.a = Math.atan2(t.y-this.y, t.x-this.x);
        else this.a+=Math.PI;
    }
    draw(c) {
        c.translate(this.x,this.y); c.rotate(this.a); c.fillStyle=this.c;
        let w=this.perf?25:16; c.fillRect(-w/2,-3,w,6); c.setTransform(1,0,0,1,0,0);
    }
}

class Enemy {
    constructor(x,y) { this.type='e'; this.x=x;this.y=y; this.t=1.5; }
    update(dt) {
        let dx=State.player.x-this.x, dy=State.player.y-this.y;
        let d=Math.hypot(dx,dy), a=Math.atan2(dy,dx);
        let spd = 120 + State.score/60;
        if(d>280) { this.x+=Math.cos(a)*spd*dt; this.y+=Math.sin(a)*spd*dt; }
        else { this.x+=Math.cos(a+1.8)*spd*0.5*dt; this.y+=Math.sin(a+1.8)*spd*0.5*dt; }
        this.t-=dt;
        if(this.t<=0) {
            this.t = Math.max(0.4, 2.0-State.score/3000)+Math.random()*0.5;
            State.entities.push(new Bullet(this.x,this.y,a,true)); AudioSys.sfx.sh();
        }
    }
    draw(c) { c.translate(this.x,this.y); c.fillStyle='#f44'; c.fillRect(-10,-10,20,20); c.setTransform(1,0,0,1,0,0); }
}

class Part {
    constructor(x,y,c) { this.x=x;this.y=y;this.c=c; let a=Math.random()*7,s=Math.random()*200+50; this.vx=Math.cos(a)*s; this.vy=Math.sin(a)*s; this.l=1; }
    update(dt) { this.x+=this.vx*dt; this.y+=this.vy*dt; this.l-=3*dt; }
    draw(c) { c.globalAlpha=this.l; c.fillStyle=this.c; c.fillRect(this.x,this.y,6,6); c.globalAlpha=1; }
}

// --- 循环 ---
function Init() {
    AudioSys.init(); Input.init();
    document.getElementById('menu').classList.add('hidden');
    document.getElementById('game-over-text').classList.add('hidden');
    State.score=0; State.entities=[]; State.particles=[];
    State.timeScale=1.0; State.tutorial=true; State.waitInput=false;
    State.player = new Player(W/2,H/2); State.active=true; State.lastTime=performance.now();
    UI.msg("SYSTEM START","#0ff"); UI.upd(); requestAnimationFrame(Loop);
}

function Loop() {
    if(!State.active) return;
    requestAnimationFrame(Loop);
    if(State.freeze>0) { State.freeze--; Render(); return; }
    
    let now=performance.now(); let dt=Math.min((now-State.lastTime)/1000, 0.1); State.lastTime=now;
    
    if(State.timeScale<1.0) {
        let t = State.waitInput ? 0.02 : 1.0;
        State.timeScale += (t-State.timeScale)*0.15;
    }
    let sDt = dt * State.timeScale;

    if(State.player) State.player.update(dt); // 玩家真时移动
    Spawner(sDt);

    for(let i=State.entities.length-1; i>=0; i--) {
        let e=State.entities[i];
        e.update(sDt * ((State.tutorial&&e.h)?0.5:1)); // 教学子弹减速
        if(e.x<-100||e.x>W+100||e.y<-100||e.y>H+100||e.dead) { State.entities.splice(i,1); continue; }
        Coll(State.player, e);
    }
    State.particles.forEach(p=>{p.update(sDt);if(p.l<=0)p.l=0});
    State.particles=State.particles.filter(p=>p.l>0);
    
    if(State.shake>0) State.shake*=0.9;
    Render();
}

let spT=0;
function Spawner(dt) {
    let max = State.tutorial ? 1 : 3+Math.floor(State.score/1000);
    if(State.entities.filter(e=>e.type==='e').length < max) {
        spT-=dt;
        if(spT<=0) {
            spT=Math.max(0.4, 2.0-State.score/4000);
            let a=Math.random()*7, r=Math.max(W,H)/2+50;
            State.entities.push(new Enemy(W/2+Math.cos(a)*r, H/2+Math.sin(a)*r));
        }
    }
}

function Coll(p, e) {
    if(e.type==='b') {
        let d = Math.hypot(p.x-e.x, p.y-e.y);
        if(e.h) {
            // 教程触发
            if(State.tutorial && !e.sl && d<180 && d>50) {
                e.sl=true; State.timeScale=0.02; State.waitInput=true;
                document.getElementById('guide').style.display='block'; AudioSys.sfx.sl();
            }
            // 弹反
            if(p.pt>0 && d<140) {
                let isPerf = d>90;
                e.reflect(isPerf, false); // 手动反弹
                
                State.timeScale=0.1; State.freeze=isPerf?6:4; State.shake=isPerf?25:15;
                if(isPerf) {
                    State.score+=300; AudioSys.sfx.pf(); FX.burst(e.x,e.y,'#ffd700',20); UI.msg("PERFECT!","#fd0");
                } else {
                    State.score+=100; AudioSys.sfx.p(); FX.burst(e.x,e.y,'#0ff',10);
                }

                if(State.waitInput) {
                    State.waitInput=false; State.tutorial=false;
                    document.getElementById('guide').style.display='none'; UI.msg("LIMITER OFF","#0ff");
                }
                UI.upd();
            } 
            // 受伤/自动
            else if (d<18) {
                // 如果在教学等待期(waitInput)，或者教学模式下还没操作，强制自动
                if(State.waitInput || (State.tutorial && !State.player.pt)) {
                    e.reflect(false, true); // 自动反弹
                    UI.msg("AUTO (0分)", "#888");
                    State.waitInput=false; document.getElementById('guide').style.display='none';
                } else {
                    e.dead=true; p.hp--; AudioSys.sfx.h(); FX.burst(p.x,p.y,'#f00',20); State.shake=30;
                    UI.upd(); if(p.hp<=0) End();
                }
            }
        } else {
            // 我方杀敌
            State.entities.forEach(en => {
                if(en.type==='e' && !en.dead && Math.hypot(en.x-e.x, en.y-e.y)<35) {
                    en.dead=true;
                    if(!e.perf) e.dead=true;
                    // *** 核心修复：自动反弹的子弹(e.auto) 不加分 ***
                    if(!e.auto) {
                         State.score+=200; 
                         UI.upd();
                         FX.burst(en.x,en.y,'#f05',15); 
                    } else {
                         // 自动杀敌给个灰色爆炸
                         FX.burst(en.x,en.y,'#666',10); 
                    }
                    AudioSys.sfx.k();
                }
            });
        }
    }
}

function Render() {
    ctx.fillStyle = `rgba(5,5,8,${0.4+(1-State.timeScale)*0.3})`; ctx.fillRect(0,0,W,H);
    ctx.save();
    if(State.shake>0.5) ctx.translate((Math.random()-.5)*State.shake, (Math.random()-.5)*State.shake);
    ctx.globalCompositeOperation='lighter';
    State.entities.forEach(e=>e.draw(ctx));
    State.particles.forEach(p=>p.draw(ctx));
    if(State.player) State.player.draw(ctx);
    ctx.globalCompositeOperation='source-over'; ctx.restore();
}

const FX = { burst:(x,y,c,n)=>{ for(let i=0;i<n;i++)State.particles.push(new Part(x,y,c)); } };
const UI = {
    msg:(t,c)=>{ 
        let e=document.getElementById('msg'); e.innerText=t; e.style.color=c; 
        e.style.opacity=1; e.style.transform='scale(1.2)'; 
        setTimeout(()=>{e.style.opacity=0;e.style.transform='scale(0.8)'},800); 
    },
    upd:()=>{
        document.getElementById('ui-score').innerText=State.score;
        document.querySelectorAll('.hp-bit').forEach((e,i)=>i<State.player.hp?e.classList.remove('off'):e.classList.add('off'));
    }
};
function End() {
    State.active=false; 
    document.getElementById('menu').classList.remove('hidden');
    let t = document.getElementById('game-over-text');
    t.innerText="链接中断 SCORE: "+State.score; t.classList.remove('hidden');
    document.getElementById('btn-start').innerText="重置系统";
}

document.getElementById('btn-start').onclick = Init;
window.onresize = ()=>{W=canvas.width=innerWidth; H=canvas.height=innerHeight;};

</script>
</body>
</html>
